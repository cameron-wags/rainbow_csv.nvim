==============================================================================
*rainbow_csv* - highlight columns in csv/tsv/*sv files in different colors

==============================================================================

Rainbow CSV: highlight columns in csv/tsv files and execute SELECT and UPDATE
queries in SQL-like language

1. Overview        |overview|
2. Mappings        |mappings|
3. Commands        |commands|
4. Configuration   |configuration|
5. Tips            |tips|
6. RBQL            |RBQL|



==============================================================================
1. Overview                                                        *overview*

Main features:  ~
*  Highlight CSV columns in different rainbow colors. 
*  Provide info about column under the cursor
*  Provide `SELECT` and `UPDATE` queries in RBQL: SQL-like transprogramming query language.
*  Consistency check for csv files (CSVLint)
*  Align and Shrink CSV fields (add/remove trailing spaces in fields)

There are 4 ways to enable csv columns highlighting:
1.  CSV autodetection based on file content and/or extension  
2.  Manual CSV delimiter selection with |:RainbowDelim| command with cursor over the delimiter  
3.  Manual CSV delimiter selection with |:RainbowMultiDelim| for multi-character delimiters  
4.  Execute `:set ft=csv` or `:set ft=tsv` for CSV/TSV dialects. For other separators use |:RainbowDelim|  

To run an RBQL query either press <F5> or enter the query in vim command line e.g. >
    :Select a1, a2
<
As soon as you finish entering "select" (or update) and press whitespace, the plugin will show column names in the status line.  

The core functionality of the plugin is written in pure vimscript, no additional libraries required.  

github page of the project: https://github.com/mechatroner/rainbow_csv
Github README file may contain more up-to-date info than this help file. 


Built-in and autogenerated filetypes  ~
Rainbow CSV has 5 built-in CSV filetypes and infinite number of autogenerated filetypes.  
Each Rainbow CSV filetype is mapped to a separator and "policy" which describes additional properties e.g. if separator can be escaped inside double quoted field.  
If user select a separator that doesn't map to one of the built-in filetypes, Rainbow CSV will dynamically generate a filetype syntax file and put it into the "syntax" folder.  
List of built-in filetypes:  

Filetype          Separator        Extension    Properties                         
csv               , (comma)        .csv         Ignored inside double-quoted fields
tsv               \t (TAB)         .tsv .tab                                       
csv_semicolon     ; (semicolon)                 Ignored inside double-quoted fields
csv_whitespace    whitespace                    Consecutive whitespaces are merged 
csv_pipe          | (pipe)                                                         
rfc_csv           , (comma)                     Same as "csv" but allows multiline fields
rfc_semicolon     ; (semicolon)                 Same as "csv_semicolon" but allows multiline fields


Associating file extensions with CSV dialects  ~
In most cases the built-in autodetection algorithm should correctly detect correct CSV dialect for all CSV tables that you open in Vim, but if you have disabled the autodetection algorithm or don't want to rely on it for some reason, you can manually associate file extensions with available csv dialects.  
Example: to associate ".dat" extension with "csv_pipe" dialect and ".csv" extension with "csv_semicolon" add the folowing lines to your .vimrc: >
    autocmd BufNewFile,BufRead *.csv   set filetype=csv_semicolon
    autocmd BufNewFile,BufRead *.dat   set filetype=csv_pipe
<

Rainbow highlighting for non-table files  ~
You can use rainbow highlighting and RBQL even for non-csv/tsv files.  
E.g. you can highlight records in log files, one-line xmls and other delimited records.  
You can even highlight function arguments in your programming language using comma or comma+whitespaces as a delimiter for |:RainbowDelim| or |:RainbowMultiDelim| commands.  
And you can always turn off the rainbow highlighting using |:NoRainbowDelim| command.  

Working with multiline CSV fields  ~
In rare cases some CSV files can contain double-quoted fields spanning multiple lines.  
To work with such files you can set filetype to either "rfc_csv" or "rfc_semicolon".  

==============================================================================
2. Mappings                                                        *mappings*

Key 		Action
<F5>		Start query editing for the current csv file
<F5>		Execute currently edited query



==============================================================================
3. Commands                                                        *commands*

*:RainbowDelim*

Mark current file as a table and highlight it's columns in rainbow colors.
Character under the cursor will be used as a delimiter. The delimiter will be
saved in a config file for future vim sessions.

You can also use this command for non-csv files, e.g. to highlight function 
arguments in source code in different colors. To return back to original
syntax highlighting run |:NoRainbowDelim|


*:RainbowMultiDelim*

Same as |:RainbowDelim|, but works with multicharacter separators.
Visually select the multicharacter separator (e.g. `~#~`) and run |:RainbowMultiDelim| command.


*:NoRainbowDelim*

Disable rainbow columns highlighting for the current file.


*:CSVLint*

The linter checks the following:  
* consistency of double quotes usage in CSV rows  
* consistency of number of fields per CSV row  


*:RainbowAlign*

Align CSV columns with whitespaces.  
Don't run this command if you treat leading and trailing whitespaces in fields as part of the data.  
You can edit aligned CSV file in Vim column-edit mode (<Ctrl+v>).  


*:RainbowShrink*

Remove leading and trailing whitespaces from all fields. Opposite to RainbowAlign


*:Select* {...}

Allows to enter RBQL select query as vim command. 
Example: >
  :Select a1, a2 order by a1
<

*:Update* {...}

Allows to enter RBQL update query as vim command.
Example >
  :Update a1 = a1 + " " + a2
<

*:RainbowName* {name}

Assign any name to the current table. You can use this name in join operation
instead of the table path.
Example: >
  JOIN customers ON a1 == b1
<
Intead of: >
  JOIN /path/to/my/customers/table ON a1 == b1
<


==============================================================================
4. Configuration                                              *configuration*

*g:disable_rainbow_hover*
Set to `1` to stop showing info about the column under the cursor in Vim command line  
Example: >
let g:disable_rainbow_hover = 1
<


*g:rcsv_colorpairs*
List of color name pairs to customize rainbow highlighting.
Each entry in the list is a pair of two colors: the first color is for terminal mode, the second one is for GUI mode.
Example: >
  let g:rcsv_colorpairs = [['red', 'red'], ['blue', 'blue'], ['green', 'green'], ['magenta', 'magenta'], ['NONE', 'NONE'], ['darkred', 'darkred'], ['darkblue', 'darkblue'], ['darkgreen', 'darkgreen'], ['darkmagenta', 'darkmagenta'], ['darkcyan', 'darkcyan']]
<


*g:rbql_output_format*
Default: "input"
Allowed values: "tsv", "csv", "input"

Format of RBQL result set tables.

* input: same format as the input table
* tsv: doesn't allow quoted tabs inside fields. 
* csv: is Excel-compatible and allows quoted commas.

Essentially format here is a pair: delimiter + quoting policy.
This setting for example can be used to convert files between tsv and csv format:
*  To convert csv to tsv: 
   1.  open csv file.
   2.  execute "let g:rbql_output_format='tsv'" 
   3.  execute ":Select *"
* To convert tsv to csv: 
   1.  open tsv file.
   2.  execute ":let g:rbql_output_format='csv'"
   3.  execute ":Select *"


*g:rbql_backend_language*
Default: "python"

Scripting language to use in RBQL expression. Either "js" or "python"
To use JavaScript add "let g:rbql_backend_language = 'js'" to .vimrc


*g:rcsv_delimiters*
Default: ["\t", ","]

By default plugin checks only TAB and comma characters during autodetection stage.
You can override this variable to autodetect tables with other separators. 
Example: >
  let g:rcsv_delimiters = ["\t", ",", ";"]
<

*g:disable_rainbow_csv_autodetect*

csv autodetection mechanism can be disabled by setting this variable value to 1.
Manual delimiter selection would still be possible.


*g:rcsv_max_columns*
Default: 30

Autodetection will fail if buffer has more than |g:rcsv_max_columns| columns.
You can increase or decrease this limit.


==============================================================================
5. Tips                                                                *tips*

Rainbow highlighting for non-table files ~

You can use rainbow highlighting and |RBQL| even for non-csv/tsv files.
E.g. you can highlight records in log files, one-line xmls and other delimited records.
You can even highlight function arguments in your programming language using comma as
a delimiter for |:RainbowDelim| command.
And you can always turn off the rainbow highlighting using |:NoRainbowDelim| command.


==============================================================================
6. RBQL                                                                *RBQL*

RBQL stands for "RainBow Query Language"


Main Features ~
*  Use Python or JavaScript expressions inside SELECT, UPDATE, WHERE and ORDER BY statements
*  Result set of any query immediately becomes a first-class table on it's own.
*  Output entries appear in the same order as in input unless ORDER BY is provided.
*  Input csv/tsv spreadsheet may contain varying number of entries (but select query 
   must be written in a way that prevents output of missing values)
*  Works out of the box, no external dependencies.


Supported SQL Keywords (Keywords are case insensitive) ~

*  SELECT TOP {N} DISTINCT [ COUNT ]
*  UPDATE [ SET ]
*  WHERE
*  ORDER BY ... [ DESC | ASC ]
*  [ [ STRICT ] LEFT | INNER ] JOIN
*  GROUP BY

All keywords have the same meaning as in SQL queries. You can check them here
https://www.w3schools.com/sql/default.asp

But there are also two new keywords: DISTINCT COUNT and STRICT LEFT JOIN.
*  DISTINCT COUNT is like DISTINCT, but adds a new column to the "distinct" 
   result set: number of occurences of the entry, similar to "uniq -c" unix command.
*  STRICT LEFT JOIN is like LEFT JOIN, but generates an error if any key 
   in left table "A" doesn't have exactly one matching key in the right table "B".

Some important rules:
*  UPDATE SET is synonym to UPDATE, because in RBQL there is no need to
   specify the source table.
*  UPDATE has the same semantic as in SQL, but it is actually a special type
   of SELECT query.
*  JOIN statements must have the following form: >
   <JOIN KEYWORD> ( {/path/to/table.tsv} | {table_name} ) ON a{i} == b{j}
<

Special RBQL variables ~

Variable name		Variable Type	Variable description

a1, a2,..., a{N}	string		Value of i-th column
b1, b2,..., b{N}	string		Value of i-th column in join table B
NR	                integer		Line number (1-based)
NF	                integer		Number of fields in line


Aggregate functions and queries ~
RBQL supports the following aggregate functions, which can also be used with
"GROUP BY" keyword:

COUNT(), MIN(), MAX(), SUM(), AVG(), VARIANCE(), MEDIAN(), FOLD()

Limitations~
*  Aggregate function are CASE SENSITIVE and must be CAPITALIZED.
*  Aggregate functions inside Python (or JS) expressions are not supported, but you can use expressions inside aggregate functions.
   E.g. this is invalid: >
   MAX(float(a1) / 1000)
<   But this is valid: >
   MAX(a1) / 1000
< 

Examples of RBQL queries with Python expressions~
>
  select top 100 a1, a2 * 10, a4.length where a1 == "Buy" order by parseInt(a2)
  select * order by Math.random()
  select top 20 len(a1) / 10, a2 where a2 in ["car", "plane", "boat"]
  update set a3 = 'US' where a3.find('of America') != -1
  select * where NR <= 10
  select a1, a4
  select * order by int(a2) desc
  select NR, *
  select * where re.match(".*ab.*", a1) is not None
  select a1, b1, b2 inner join ./countries.txt on a2 == b1 order by a1, a3
  select distinct count len(a1) where a2 != 'US'
  select MAX(a1), MIN(a1) where a2 != 'US' group by a2, a3
<

Examples of RBQL queries with JavaScript expressions~
>
  select top 100 a1, a2 * 10, a4.length where a1 == "Buy" order by parseInt(a2)
  select * order by Math.random()
  update set a3 = 'US' where a3.indexOf('of America') != -1
  select * where NR <= 10
  select a1, a4
  select * order by parseInt(a2) desc
  select NR, *
  select a1, b1, b2 inner join ./countries.txt on a2 == b1 order by a1, a3
  select distinct count a1.length where a2 != 'US'
  select MAX(a1), MIN(a1) where a2 != 'US' group by a2, a3
<



vim:tw=78:ts=8:ft=help
